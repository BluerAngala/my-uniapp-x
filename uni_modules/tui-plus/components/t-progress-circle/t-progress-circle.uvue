<template>
	<t-view v-bind="extendsAttrs" :main-class="`twh-200 dr ${mainClass}`">
		<t-canvas ref="circlepCanvas" main-class="twh-100%" @initFinished="canvasInit">
		</t-canvas>
		<t-view v-if="showLabel" main-class="fc da di-0">
			<t-text v-bind="extendsAttrs" main-class="" :text="`${nowValue}${unit}`"></t-text>
		</t-view>
	</t-view>
</template>
<script setup>
	/**
	 * ProgressCircle 环形进度条
	 * @date 2025-05-31 12:05:50
	 * @author TanYuan
	 * @description 环形进度条组件是一个可定制的UI组件，用于显示圆形进度指示，支持自定义线条宽度、颜色，并可显示进度百分比。
	 * @example /pagesA/basics/circleprogress/circleprogress
	 * @tutorial https://life.yundie.xyz/tui3.0/docs/component/t-progress-circle.html
	 * @example /pagesA/basics/circleprogress/circleprogress
	 * @property {String} size=[large|medium|small|mini] 组件尺寸
	 * @value large 大尺寸，按钮的尺寸较大，适用于需要强调操作或易于点击的区域。
	 * @value medium 中尺寸，按钮的尺寸适中，可能是默认尺寸，适用于大多数场景。
	 * @value small 小尺寸，按钮的尺寸较小，适用于空间有限或操作不是特别重要的区域。
	 * @value mini 迷你，按钮的尺寸最小，适用于紧凑布局或辅助操作。
	 * @property {String} type=[info|primary|error|warning|success] 组件类型(默认：p)
	 * @value info 信息提示场景，通常用于提供一般的通知信息，不涉及特别的重要性或紧急性。
	 * @value primary 正常使用场景，可能用于强调某些主要的操作或信息，比如主要的按钮或导航链接。
	 * @value error 错误提示场景，用于指示出现了错误或问题，需要用户的注意。
	 * @value warning 警告提示场景，用于提示用户关于潜在的问题或需要注意的事项。
	 * @value success 成功提示场景，用于指示一个操作或过程已经成功完成。
	 * @property {Boolean} disabled=[false|true] 组件是否禁用
	 * @property {Boolean} stop=[false|true] 是否阻止事件冒泡（Tui统一写法处理事件冒泡）(默认: false)
	 * @property {Boolean} hover=[false|true] 是否有点击效果(默认：true)
	 * @property {String} path 点击组件后跳转的页面路径，如果为空则响应点击事件，如果不为空则跳转页面不会响应单击事件。(默认: "")
	 * @property {String} mainClass 组件根节点的样式。(默认: "")
	 * @property {String} nativeClass 组件根节点原生样式。(默认: "")
	 * @property {String} effect=[normal|dark|light|plain] 组件显示主题(默认 "normal")
	 * @value normal 正常
	 * @value dark 深色
	 * @value light 浅色
	 * @value plain 镂空
	 * @property {String} backgroundLineWidth 背景圈线条宽度(默认：20rpx)
	 * @property {String} activeLineWidth 进度圈线条宽度(默认：20rpx)
	 * @property {String} inactiveColor 进度条未激活时的颜色(默认：#ececec)
	 * @property {String} activeColor 进度条激活时的颜色
	 * @property {Number} modelValue 双向绑定的值(默认：1)
	 * @property {String} unit 进度条值的单位(默认：%)
	 * @property {Boolean} showLabel 是否显示进度标签
	 * @value true 是
	 * @value false 否
	 * @property {Number} duration 进度条过渡的持续时间，单位为毫秒(默认：300)
	 */

	import { getPx, addUnit } from '../../common/model/util'
	type OPTIONS = {
		start : number,
		end : number,
		duration : number,
		run : (current : number) => void,
		complete : () => void
	}
	type ANIMATECALLBACK = {
		stop : () => void
	}
	import { CommonProps, useTuiThemes } from '../../common/props/index.uts';
	interface ProgressCircleProps extends CommonProps {
		backgroundLineWidth : string
		activeLineWidth : string
		inactiveColor : string
		activeColor : string
		modelValue : number
		unit : string
		showLabel : boolean
		duration : number
	}

	const props = withDefaults(defineProps<ProgressCircleProps>(), {
		path: '',
		hover: false,
		type: '',
		disabled: false,
		stop: false,
		effect: '',
		size: '',
		mainClass: '',
		nativeClass: '',
		backgroundLineWidth: "20rpx",
		activeLineWidth: "20rpx",
		inactiveColor: "#ececec",
		activeColor: "",
		modelValue: 0,
		unit: "%",
		showLabel: false,
		duration: 300
	});
	const { extendsAttrs, getColorToValue } = useTuiThemes(props)
	const canvasCtx = ref<CanvasRenderingContext2D | null>(null);
	const animationTaskId = ref<number>(0);
	const nowValue = ref<number>(0);
	const oldValue = ref<number>(0);
	const nowback = ref<ANIMATECALLBACK>({
		stop: () => { },
	});
	const drawSize = ref<number>(0);
	const circlepCanvas = ref<ComponentPublicInstance | null>(null)
	
	const _backgroundLineWidth = computed(() : number => {
		let w = getPx(addUnit(props.backgroundLineWidth))
		return w
	})
	
	const _activeLineWidth = computed(() : number => {
		let w = getPx(addUnit(props.activeLineWidth))
		return w
	})
	
	// 计算两个圆的最大线宽，用于确定画布内可用的最大半径
	const _maxLineWidth = computed(() : number => {
		return Math.max(_backgroundLineWidth.value, _activeLineWidth.value)
	})
	
	// 计算背景圈的半径（基于最大线宽）
	const _backgroundRadius = computed(() : number => {
		return (drawSize.value - _maxLineWidth.value) / 2
	})
	
	// 计算进度圈的半径（基于最大线宽，让进度圈在背景圈中间）
	const _activeRadius = computed(() : number => {
		// 如果背景圈比进度圈宽，进度圈要在背景圈中间
		if (_backgroundLineWidth.value > _activeLineWidth.value) {
			return (drawSize.value - _backgroundLineWidth.value) / 2
		}
		// 如果进度圈比背景圈宽或相等，直接使用最大线宽计算
		return (drawSize.value - _maxLineWidth.value) / 2
	})
	
	function animate(options : OPTIONS) : ANIMATECALLBACK {
		const start = options.start;
		const end = options.end;
		const duration = options.duration;
		let current : number;
		let startTime = 0;
		let isRunning = true;
		
		function run() {
			if (startTime <= 0) {
				startTime = Date.now();
			}
			const progress = Math.min((Date.now() - startTime) / duration, 1);
			current = start + (end - start) * progress;
			if (isRunning) {
				options.run(current);
			}
			if (progress < 1 && isRunning) {
				if (animationTaskId.value != 0) {
					cancelAnimationFrame(animationTaskId.value)
					animationTaskId.value = 0
				}
				animationTaskId.value = requestAnimationFrame((_ : number) => {
					run()
				})
			} else {
				options.complete();
			}
		}
		run();
		return {
			stop: () => {
				isRunning = false;
			}
		} as ANIMATECALLBACK;
	}

	function dreawer(start : number, end : number) {
		let ctx = canvasCtx.value!
		ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)
		
		let cx = drawSize.value / 2
		let cy = cx
		
		// 绘制背景圈
		ctx.beginPath()
		ctx.strokeStyle = props.inactiveColor
		ctx.lineWidth = _backgroundLineWidth.value
		ctx.lineCap = "round"
		ctx.arc(cx, cy, _backgroundRadius.value, 0, Math.PI * 2, false)
		ctx.stroke()
		
		// 绘制进度圈
		if (end > 0) {
			// 绘制从0到起始角度的进度圈部分
			if (start > 0) {
				ctx.beginPath()
				ctx.strokeStyle = props.activeColor != '' ? props.activeColor : getColorToValue.value
				ctx.lineWidth = _activeLineWidth.value
				ctx.lineCap = "round"
				ctx.arc(cx, cy, _activeRadius.value, 0, start, false)
				ctx.stroke()
			}
			
			// 绘制从起始角度到结束角度的进度圈部分
			ctx.beginPath()
			ctx.strokeStyle = props.activeColor != '' ? props.activeColor : getColorToValue.value
			ctx.lineWidth = _activeLineWidth.value
			ctx.lineCap = "round"
			ctx.arc(cx, cy, _activeRadius.value, start, end, false)
			ctx.stroke()
		}
	}
	
	function play() {
		let ctx = canvasCtx.value!
		nowback.value.stop()
		if (animationTaskId.value != 0) {
			cancelAnimationFrame(animationTaskId.value)
			animationTaskId.value = 0
		}
		ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)
		nowback.value = animate({
			start: 0,
			end: 100,
			duration: props.duration,
			complete() {
				// 动画完成
			},
			run(cureent : number) {
				let angle = Math.PI * 2;
				if (nowValue.value >= oldValue.value) {
					let startAngle = (oldValue.value / 100) * angle
					let endAngle = ((cureent / 100) * (nowValue.value - oldValue.value) / 100) * angle
					endAngle = Math.max(endAngle, 0)

					dreawer(startAngle, endAngle + startAngle)
				} else {
					let startAngle = (nowValue.value / 100) * angle
					let endAngle = ((cureent / 100) * (oldValue.value - nowValue.value) / 100) * angle
					let diff = (oldValue.value - nowValue.value) / 100 * angle
					dreawer(startAngle, diff + startAngle - endAngle)
				}
			}
		} as OPTIONS)
	}
	
	function canvasInit(ctx : CanvasContext) {
		circlepCanvas.value?.$callMethod('getInfo', (rect : NodeInfo) => {
			canvasCtx.value = ctx.getContext('2d')
			drawSize.value = rect.width!
			nowValue.value = props.modelValue
			play();
		})
	}

	watch(() : number => props.modelValue, (newval : number) => {
		if (newval != nowValue.value) {
			oldValue.value = nowValue.value
			nowValue.value = newval
			play();
		}
	})

	onBeforeUnmount(() => {
		if (animationTaskId.value != 0) {
			cancelAnimationFrame(animationTaskId.value)
			animationTaskId.value = 0
		}
	})
</script>