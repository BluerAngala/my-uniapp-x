---
inclusion: fileMatch
fileMatchPattern: "*.uts,*.uvue"
---

## uts 和 ts 的差异

ts 虽然有类型，但类型要求不严格。而 uts 为了编译为原生语言，是完全的强类型。

另外为了确保跨平台、高性能，uts 通过规范约束了 ts 中过于灵活而影响开发正确性或者给运行时带来不必要额外开销的特性。

本文罗列了在 uts 跨端开发时限制的 ts 特性，并提供了重构代码的建议。

> uni-app x下uts编译器目前[已知的一些问题](https://doc.dcloud.net.cn/uni-app-x/uts/compiler-known-issues.html)

> uni-app x下部分[运行错误的说明](https://doc.dcloud.net.cn/uni-app-x/uts/runtime-known-issues.html)

### 概述

#### 强制使用静态类型

静态类型是 uts 最重要的特性之一。如果程序采用静态类型，即所有类型在编译时都是已知的，那么开发者就能够容易理解代码中使用了哪些数据结构。
同时，由于所有类型在程序实际运行前都是已知的，编译器可以提前验证代码的正确性，从而可以减少运行时的类型检查，有助于提升性能。

基于上述考虑，uts 中的 any 类型与 ts 中的 any 并不一样，它是一个根据目标平台自动适配的跨端类型，通常用于表示"任意的非空类型"，
在使用时仍需类型转换后才能访问具体类型的方法和属性。

#### 不支持结构化类型系统

结构化类型系统（structural typing）是 ts 的一个特性，它意味着类型的兼容性和等价性是基于类型的结构（即它们的属性和方法）；
而在跨端开发时，uts 采用名义类型系统（nominal typing），类型兼容性检查基于类型名称和显式的继承/实现关系。
即使两个类型具有完全相同的结构，如果没有显式的继承/实现关系，它们也不能互相赋值。
这与 Kotlin 、Swift 、ArkTS 等静态语言的类型系统保持一致，有助于确保类型安全和代码的可维护性。

## 约束说明

### 1. 核心语言特性

#### 不支持 undefined
- 不支持 undefined。所有变量必须赋值初始化后才能使用。如果需要使用空，请使用 null。
- UTS 使用 null 替代 undefined

#### 条件语句必须使用布尔类型
- 所有条件语句(if、while、do-while、三元运算符、for 循环的条件部分)必须使用布尔类型作为条件。
- 不支持 ts 中的隐式类型转换和 truthy/falsy 值。

#### 对象字面量默认为 UTSJSONObject 类型
- 在 UTS 中，所有没有明确类型标注或上下文推断不出具体类型的对象字面量都会被推导为 UTSJSONObject 类型。
- 推荐使用type替代UTSJSONObject

#### 对象字面量仅支持构造 type 定义的对象类型，不支持 interface
- 在 UTS 中，interface 有其他使用场景，所以对象字面量赋值只能给 type 关键词定义的对象类型。

#### 不支持变量和函数的声明提升 (hoisting)
- 所有变量和函数必须先声明后使用，严格注意顺序，不能访问未声明的变量或函数(包括函数自身)。

#### 使用 let 而非 var
- 请使用 let 或 const 声明变量。

### 2. 类型系统相关

#### 对象字面量不能用于类型声明
- 不支持直接使用对象字面量声明类型，可以使用 type 别名、类或者接口声明类型。

#### type 定义对象类型时不支持嵌套对象字面量
- 当使用 type 定义对象字面量类型时，不支持对象字面量嵌套。如果有嵌套需求，需要提取出来定义一个新的 type。

#### 使用具体的类型而非 unknown
- 不支持声明类型为 unknown，unknown 仅支持在泛型中使用。

#### 不支持条件类型
- 不支持条件类型别名，引入带显式约束的新类型。

#### 不支持映射类型
- 不支持映射类型，请使用其他语法来表示相同的语义。

#### 不支持 utility 类型
- 不支持 TypeScript 中的 Utility Types，如 Partial、Required、Readonly、Pick、Omit、Record 等。

#### 不支持 as const 断言
- 不支持 as const 断言。

#### 不支持确定赋值断言
- 不支持确定赋值断言，例如：let v!: T。改为在声明变量的同时为变量赋值。

#### 类型别名不能出现在局部作用域中
- 使用 type 关键字定义的类型别名不能在局部进行声明，只能在顶层作用域中。

### 3. 类和对象相关

#### 不支持以#开头的私有字段
- 不支持使用 # 符号开头声明的私有字段。改用 private 关键字。

#### class 不支持通过索引访问字段
- class 不支持动态声明字段，不支持动态访问字段。使用点操作符访问 class 字段。

#### 不支持静态块
- 不同平台对类中静态块支持有差异。使用其他方式实现静态初始化，如构造函数中。

#### class 不能被用作对象
- class 声明的是一个新的类型，不是一个值。因此，不支持将 class 用作对象。

#### 类继承时必须显示声明构造器
- 继承类时必须显式声明构造器。

#### 类不允许 implements
- 不允许类被 implements，只有接口可以被 implements。

#### 接口不能继承类
- 不支持接口继承类，接口只能继承接口。

#### 接口不能出现在局部作用域中
- 接口不能出现在局部作用域中

#### 不支持修改对象的方法
- 不支持修改对象的方法。如果需要为某个特定的对象增加方法，可以封装函数或者使用继承的机制。

#### type、class 或 interface 的属性方法不支持定义泛型信息
- type、class 或 interface 的属性类型为方法时，不支持在属性方法上定义泛型信息。

#### 类不能作为值使用
- 类不能作为值使用

#### Enum成员初始化器仅支持数字或字符串
- Enum成员初始化器仅支持数字或字符串。

#### Enum声明必须是顶级声明
- Enum声明必须是顶级声明。

### 4. 函数相关

#### 使用 class 而非具有 call signature 的类型
- 不支持对象类型中包含 call signature。

#### 使用 class 而非具有构造签名的类型
- 不支持对象类型中的构造签名。改用类。

#### 不支持构造函数类型
- 不支持使用构造函数类型，改用 lambda 函数。

#### 函数声明不能作为值使用
- 在 UTS 中,通过 function 关键字声明的函数不能作为值传递。如果需要将函数作为值使用，请使用函数表达式。

#### 不支持对函数声明属性
- 不支持对函数声明属性。

#### 不支持 Function.apply、Function.call 和 Function.bind
- 不支持 Function.apply、Function.call 和 Function.bind。this 的语义仅限于在 class 中使用的传统 OOP 风格。

#### 在函数表达式中不可以访问未声明的变量或函数（包括自身）
- UTS 中不存在变量提升，在函数表达式中不可以访问未声明的变量或函数（包括自身）

#### 不支持函数分配给接口
- 无法将函数分配给接口。

### 5. 模块和命名空间

#### 不支持命名空间
- 不支持将命名空间用作对象，可以使用类或模块。

#### 不支持 require 和 import 赋值表达式
- 不支持通过 require 导入，也不支持 import 赋值表达式，改用 import。

#### 不支持 export = ...语法
- 不支持 export = ...语法，改用常规的 export 或 import。

### 6. 类型检查和转换

#### 使用 instanceof 和 as 进行类型保护
- 不支持 is 运算符，必须用 instanceof 运算符替代。在使用之前，必须使用 as 运算符将对象转换为需要的类型。

#### 类型转换仅支持 as T 语法
- as 关键字是类型转换的唯一语法，不支持使用<type>语法进行类型转换。

### 7. 特殊语言特性

#### 不支持 Symbol()
- ts 中的 Symbol() 用于在运行时生成唯一的属性名称。由于该 API 的常见使用场景在静态类型语言中没有意义。

#### 不支持 index signature
- 不支持 index signature，改用数组或其他集合类型。
